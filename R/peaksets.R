#' Mzroll Pass Bookmarks
#'
#' @param mzroll_db_path_annot path to annotated mzroll_db generated using a subset of samples by \code{\link{reduce_mzroll_samples}}
#' @param mzroll_db_path_target path to destination mzroll_db with no annotations
#'
#' @return 0 invisibly; function operates for its side effects
#'
#' @export
mzroll_pass_bookmarks <- function(mzroll_db_path_annot, mzroll_db_path_target) {
  mzroll_db_con_annot <- mzroll_db_sqlite(mzroll_db_path_annot)
  mzroll_db_con_target <- mzroll_db_sqlite(mzroll_db_path_target)

  annot_peakset <- extract_peakset(mzroll_db_con_annot, searchTable = "Bookmarks")
  target_peakset <- extract_peakset(mzroll_db_con_target)

  matched_peaksets <- match_peaksets(annot_peakset, target_peakset, cutoff = 1)

  top_overwrite <- matched_peaksets %>%
    dplyr::group_by(groupId_target) %>%
    dplyr::arrange(match_score) %>%
    dplyr::slice(1) %>%
    dplyr::ungroup()

  retained_peakgroups <- target_peakset$peakgroups %>%
    dplyr::anti_join(top_overwrite, by = c("groupId" = "groupId_target"))

  updated_peakgroups <- target_peakset$peakgroups %>%
    dplyr::select(groupId, parentGroupId, metaGroupId) %>%
    dplyr::inner_join(top_overwrite %>%
      dplyr::select(groupId_query, groupId_target),
    by = c("groupId" = "groupId_target")
    ) %>%
    dplyr::left_join(annot_peakset$peakgroups %>%
      dplyr::select(-parentGroupId, -metaGroupId),
    by = c("groupId_query" = "groupId")
    ) %>%
    dplyr::select(-groupId_query)

  peakgroups_overwrite <- dplyr::bind_rows(retained_peakgroups, updated_peakgroups)

  DBI::dbWriteTable(mzroll_db_con_target, "peakgroups", peakgroups_overwrite, row.names = F, overwrite = T)

  DBI::dbDisconnect(mzroll_db_con_annot)
  DBI::dbDisconnect(mzroll_db_con_target)

  return(invisible(0))
}

#' Extract Peakset
#'
#' @inheritParams test_mzroll_db_con_schema
#' @param searchTable character vector of searchTables to use (or NULL for all)
#'
#' @return a peakset object (list of peaks and peakgroups)
#'
#' @export
extract_peakset <- function(mzroll_db_con, searchTable = NULL) {
  stopifnot(class(searchTable) %in% c("NULL", "character"))

  peakgroups <- dplyr::tbl(mzroll_db_con, "peakgroups") %>%
    dplyr::collect()

  if (class(searchTable) != "NULL") {
    peakgroups <- peakgroups %>%
      dplyr::filter(searchTableName %in% searchTable)
  }

  # relevant peaks
  peaks <- dplyr::tbl(mzroll_db_con, "peaks") %>%
    dplyr::collect() %>%
    dplyr::semi_join(peakgroups, by = "groupId")

  # add peak summaries to peaks, if they do not already exist
  if (!"mean_peakMz" %in% colnames(peakgroups)) {
    peakgroups <- peakgroups %>%
      dplyr::left_join(peaks %>%
        dplyr::group_by(groupId) %>%
        dplyr::summarize(
          mean_peakMz = sum(peakMz * peakAreaTop) / sum(peakAreaTop),
          mean_peakRt = sum(rt * peakAreaTop) / sum(peakAreaTop),
          mean_quality = mean(quality)
        ) %>%
        dplyr::ungroup(), by = "groupId")
  }

  peakset <- list(
    peaks = peaks,
    peakgroups = peakgroups
  )
  class(peakset) <- append("peakset", class(peakset))

  validate_mzroll_db_schema(peakset, tables = c("peakgroups", "peaks"))

  peakset
}

#' Create Peakset
# "
# " Create a peakset from a provided table of peakgroups and peaks
#'   (which may be missing some features)
#'
#' @param peakgroups a table of unique peakgroups
#' @param peaks a table of sample x peakgroup peak abundances
#'
#' @return a peakset
#'
#' @examples
#' library(dplyr)
#'
#' peakgroups <- tibble::tibble(groupId = 1:10)
#' samples <- tibble::tibble(sampleId = 1:10)
#' peaks <- tidyr::crossing(peakgroups, samples) %>%
#'   dplyr::mutate(peakId = 1:dplyr::n())
#'
#' create_peakset(peakgroups, peaks)
#'
#' @export
create_peakset <- function(peakgroups, peaks) {
  checkmate::assertDataFrame(peakgroups)
  checkmate::assertDataFrame(peaks)

  # create a table containing default fields required by the mzroll format.
  # required variables are not present since they must be user-specified.

  peakset_data <- expand_with_mzroll_defaults(
    list(peakgroups = peakgroups, peaks = peaks)
  )

  return(peakset_format_for_mzroll(peakset_data))
}

#' Match Peaksets
#'
#' Report the best match for each query groupId (first testing for sample-level agreement of peakMz, scan, and intensity, and then testing for correlation of signals across samples)
#'
#' @param query_peakset generated by \code{\link{extract_peakset}}
#' @param target_peakset generated by \code{\link{extract_peakset}}
#' @param cutoff cutoff for a valid peakset match
#' @param all_matches return all matches within tolerance rather than just the top match
#'
#' @export
match_peaksets <- function(query_peakset, target_peakset, cutoff = 1, all_matches = FALSE) {
  checkmate::assertClass(query_peakset, "peakset")
  checkmate::assertClass(target_peakset, "peakset")
  checkmate::assertNumber(cutoff, lower = 0)
  checkmate::assertLogical(all_matches, len = 1)

  variable_tolerances <- tibble::tribble(
    ~variable, ~tolerance, ~relative_or_absolute,
    "peakMz", 1e-6, "relative",
    "scan", 1, "absolute",
    "log2_peakarea", 0.2, "absolute"
  )

  nested_queries <- query_peakset$peaks %>%
    dplyr::select(groupId_query = groupId, sampleId, scan, peakMz, peakAreaTop_query = peakAreaTop) %>%
    dplyr::mutate(log2_peakarea = log2(peakAreaTop_query)) %>%
    tidyr::nest(query_sample_data = -sampleId)

  nested_targets <- target_peakset$peaks %>%
    dplyr::select(groupId_target = groupId, sampleId, scan, peakMz, peakAreaTop_target = peakAreaTop) %>%
    dplyr::mutate(log2_peakarea = log2(peakAreaTop_target)) %>%
    tidyr::nest(target_sample_data = -sampleId)

  peakset_comparisons <- dplyr::full_join(nested_queries, nested_targets, by = "sampleId") %>%
    dplyr::filter(
      !purrr::map_lgl(query_sample_data, is.null),
      !purrr::map_lgl(target_sample_data, is.null)
    ) %>%
    # compare peaksets on a sample-by-sample basis based on mz and scans
    dplyr::mutate(peak_matches = purrr::map2(query_sample_data, target_sample_data,
      join_matching_standards,
      variable_tolerances = variable_tolerances,
      distance_method = "euclidean",
      threshold = 10
    )) %>%
    dplyr::filter(!purrr::map_lgl(peak_matches, is.null)) %>%
    dplyr::select(-query_sample_data, -target_sample_data) %>%
    tidyr::unnest(peak_matches) %>%
    dplyr::group_by(groupId_query, groupId_target) %>%
    dplyr::summarize(
      n_samples = dplyr::n(),
      ic_cor = stats::cor(peakAreaTop_query, peakAreaTop_target),
      mean_match_distance = mean(match_distance)
    ) %>%
    dplyr::mutate(match_score = mean_match_distance + 10 * (1 - ic_cor)) %>%
    dplyr::ungroup()

  if (all_matches) {
    return(peakset_comparisons)
  }

  top_matches <- peakset_comparisons %>%
    dplyr::group_by(groupId_query) %>%
    dplyr::arrange(match_score) %>%
    dplyr::slice(1) %>%
    dplyr::ungroup() %>%
    dplyr::filter(match_score < cutoff)

  removed_peakgroups <- nrow(query_peakset$peakgroups) - nrow(peakset_comparisons)
  if (removed_peakgroups > 0) {
    warning(removed_peakgroups, " queried peakgroups matched not target peakgroups")
  }

  peakset_comparisons
}

#' Peakset Format for Mzroll
#'
#' Take a peakset object and remove fields which are not part of the core mzrollDB schema
#' and ensure that all required fields are present
#'
#' @param peakset generated by \code{\link{extract_peakset}}
#'
#' @return a peakset
peakset_format_for_mzroll <- function(peakset) {
  validate_mzroll_db_schema(peakset, tables = c("peakgroups", "peaks"))

  mzroll_specification <- mzroll_schema_required_classes() %>%
    dplyr::filter(table %in% c("peaks", "peakgroups"))

  # remove extraneous fields
  peakset$peaks <- peakset$peaks %>%
    dplyr::select(mzroll_specification$variable[mzroll_specification$table == "peaks"])

  peakset$peakgroups <- peakset$peakgroups %>%
    dplyr::select(mzroll_specification$variable[mzroll_specification$table == "peakgroups"])

  return(peakset)
}
